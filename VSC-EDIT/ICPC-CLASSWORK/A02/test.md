### 题目背景

果园主管希望更深入地分析一片 \( N \times M \) 的果园数据。果园被分成 \( N \) 行 \( M \) 列的格子，每个格子中记录了当前成熟水果的数量（以整数表示）。主管在查看了原始数据后，想要以某种逻辑重新排序整行，以更直观地分析果园数据的分布情况。

经过商讨，决定采用以下方案：  
- 首先查看果园的原始数据分布。
- 然后根据每行的「平均产量」来对行进行排序：平均产量较小的行在前，较大的行在后。当两行的平均产量相同时，保持它们在输入时的相对顺序（稳定排序）。

主管希望程序员能用指针数组灵活地实现这一操作，而不是直接移动大块数据。

### 题目描述

1. **数据输入与存储**：  
   - 输入 \( N, M \)，读入一个 \( N \times M \) 的二维整数矩阵 `A`（使用 `int A[N][M];` 声明）。  
   - 定义 `int *rows[N];`，使 `rows[i] = A[i];`，从而能通过 `rows` 灵活访问和调整行顺序。

2. **初次输出（原始顺序）**：  
   使用 `rows[i][j]` 按行、按列遍历打印出果园的原始数据。

3. **计算平均产量并排序**：  
   - 为每行计算平均值：`平均值 = (该行所有元素之和) / M` （结果为浮点数或双精度，保持一定精度即可）。  
   - 按平均值从小到大对行进行排序。  
   - 当有多行平均值相同，行的相对顺序不变（即对这部分需要实现稳定排序）。  
   
   **要求**：  
   - 排序时不得拷贝整行数据，仅可通过交换 `rows[i]` 中指针的位置来重排行的顺序。  
   - 可同时维护一个辅助数组 `avg[]` 存储每行的平均值，用于比较。  
   - 建议使用稳定的排序算法（如归并排序）或在比较函数中使用行索引作为最终判定条件来保持稳定性。

4. **二次输出（排序后顺序）**：  
   使用 `rows[i][j]` 再次输出数据，但此时行顺序已根据平均值重新排序。

### 输入格式

- 第一行：两个整数 \( N, M \)（\(1 \leq N,M \leq 50\)）。  
- 接下来 \( N \) 行，每行 \( M \) 个整数，表示果园各格子的产量值，绝对值不超过10000。

### 输出格式

- 首先输出 \( N \) 行原始数据的布局。
- 然后输出空一行（作为分隔）。
- 最后输出 \( N \) 行按平均值排序后的数据布局。

### 样例输入

```
3 3
10 10 10
0 10 0
5 5 5
```

### 样例输出

```
10 10 10
0 10 0
5 5 5

0 10 0
5 5 5
10 10 10
```

**解释**：  
原始数据：  
- 第0行平均值 = (10+10+10)/3 = 10  
- 第1行平均值 = (0+10+0)/3 ≈ 3.333...  
- 第2行平均值 = (5+5+5)/3 = 5

按平均值从小到大：3.33 < 5 < 10  
因此行顺序由 (0,1,2) 调整为 (1,2,0)。

---

### 子任务与数据说明

- **基础数据点**：N、M较小，考验基本输入输出和排序逻辑。  
- **中等数据点**：N、M在20以内，有多行平均值重复，考察稳定排序实现。  
- **较大数据点**：N、M接近50，数据多样化，考察程序性能与正确性。  
- **特殊数据点**：  
  - 全部行平均值相同（应保持原始顺序）。  
  - 行元素均为负数或全为0。  
  - N=1或M=1，测试边界。

---

### 提示

- 使用 `int A[N][M];` 定义二维数组。  
- `int *rows[N];` 将 `rows[i] = A[i];`。  
- 初次输出时，按 `rows[i][j]` 遍历即可。  
- 排序时维护一个 `avg[i]` 数组记录每行平均值。  
- 进行稳定排序时，C语言可用冒泡排序实现稳定性，或在比较中加入行号判断。

---