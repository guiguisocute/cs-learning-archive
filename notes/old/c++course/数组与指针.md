## 指针
~~其实曾嘉轩还对内存挺明白的这些所以就说的简洁一些~~
#### 内存地址

内存当然还是以每个字节为单位，一个字节为八位

**可以简单把每个字节称为每块内存**都有自己独特的“房门号”用于程序的识别，这个“门牌号”的实际表现形式是一串无符号有限制位数的十六进制代码（现在x86架构的计算机一般都是64位，基本相当于能表示的数无上限了）

而这些十六进制“门牌号”就是所谓的**内存地址**，在计算机中，几乎每种量都被储存在内存当中，内存地址的重要性不言而喻



**指针指向谁就是把谁的地址赋值给指针**

**当函数的返回值是指针的时候那它就是指针函数（用的时候可以说是和正常指针一模一样）**

#### 指针的定义和调用
**定义**
> 我们已经学习了内存地址的详细情况，知道所有的变量都储存在计算机的内存块中，所以直接调用变量或函数我们称之为直接访问。
但是，在C++中，也可以通过另一块内存间接操控要操作的内存
**那就是指针**

指针是一个变量，其值为另一个变量的地址，就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：
```
type *var-name;
```
在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，

注意：虽然有定义了各种指针数据类型，但因为指针是存且只能存普通变量的**首**地址量（一串32/64位十六进制数），所有的指针所占的字节都是当前编译器的`sizeof(int)`，六十四位编译器那就是八个字节，三十二位编译器就是四个字节（大多数情况下）
**为什么明明所有指针变量开辟的内存空间一样还需要声明数据类型？**
为了使指针步长有更好的维护性，*详见指针的加减法章节*


**和指针密切相关的运算符的辨析**
~~虽然曾嘉轩已经熟悉的不能熟悉了但还是提一下~~
- &在表达式的时候就是取首地址（无论是指针变量还是正常变量都行），用在声明语句的时候就是定义一个引用变量，引用是啥等会再说
- \*在表达式的时候就是取指向地址的内容（限定指针变量），用在声明语句的时候就是定义一个指针变量
- 怎么用就不用这个笔记多讲了吧
*
**与`const`的关系**
- 当 `const` 出现在 * 号左边时指针指向的数据为常量，
- 当 `const` 出现在 * 号右边时指针本身为常量。

#### 指针的加减法
在指针中，加法减法只能加减**正整数**

指针变量加一等价于将这个指针指向的位置加一个单位的**步长**
>**步长**：取决于该指针当时的数据类型，一个单位步长=sizeof(type)个字节

#### 野指针
没初始化的指针变量的缺省值 (*缺省值：跟默认值同义*）是随机的 ,它的指向是不明确的, 这样的指针形象地称为“野指针”。野指针是很危险的, 容易造成程序出错, 且程序本身无法判断指针指向是否合法。

所以就要引入一个新的概念：**空指针**——当一个指针变量被赋0值或者NULL时，则表示该指针虽然被定义了但是没指向任何内存。

#### 指针与函数

## 数组
- 数组是有一定数目的**同类元素**顺序排列而成的结构类型数据
- 一个数组在内存占有一片**连续**的储存区域
- 数组名是储存空间的首地址
- 数组的每个元素用**下标**变量标识

### 一维数组
一维堆数组的形式是*向量*
数组声明形式：
类型 标识符 [表达式]（常整形表达式）


数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引（小标）访问。

给数组赋值时，给多少个就按顺序分多少个，没给的用0填充，但完全没有给的话就是随机数的形式
### 调用数组
`double salary = balance[9];`:
上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：

- 调用以后的数组元素一样具有正常变量应该有的功能，赋值查地址给指针都可以，所以数组其实就是一个隐形指针……

####　以指针方式访问数组
数组的标识符→该数组首元素的地址，∴是常量，赋值就报错，只能通过指针简介操作
int n[10]

n==&n[0]                　　　　　*n\==n[0]
n+1==&n[1]              　　　　*(n+1)==n[1]

由此类推…

数组的加减运算符只是加索引号

数组基本上一定要和指针结合在一块才有灵活的意义
*况且本来就属于是一种指针*


#### 2021年5月8日14:31:02课堂笔记
一维数组：先定义声明后使用
example：
```c
int name[10]
```
标准的一维数组

**数组的地址**
就是数组名（example的“name”）
数组名就是地址常量，该数组的首元素的地址
`a[坐标]`，调用一维数组中的元素
但是正序列其实是坐标+1
因为默认情况下是0开始以此类推
定义数组时的**常量表达式**只能使用**纯右值**（只是定义的时候不可以用左值啊，调用的时候随便用（前提是不能溢出了））



**一维数组的初始化**
`int a[5]={1,2,3,4,5}
等价于使用下标分别赋值

*如果你给所有的元素都初始化了，可以省略定义时的方括号内容*
**一维数组的指针访问**
指针的名称就是他的首地址，每过一个元素，地址就会在首地址（0x）的基础上加上**一个该数组的数据类型单位（步长）**

指针变量也可以指向指针的首地址


数组名也可以在表达式中使用，但是都是作为数组的**首地址**进行运算符的作用，所加或者所减都是数组的**数据类型的单位长度**（比如a+3的3并不是十进制意义上的3，而是3个int的地址宽度）**数组的指针偏移计算也是这样的**

实际上，定义了指针指向数组以后，指针变量的名字就可以随意的代替数组本身的功能，除了他本身的地址不同，基本相当于使用了typedef。比如a[2]==p[2]
(`int *p = a`), 而且，因为指针的变量并不是直接地址，所以可以被当做左值使用，然而数组名是作为直接地址是右值，所以并不能被简单粗暴地带入到运算符中

### 指针数组
- 指针数组的元素类型是指针或者变量的地址
- 指针数组的元素存放的对象的地址
说明形式为  `int *name [2];`

### 指向数组的指针数组
- 存的元素指向的是整个数组而不是被指的数组的某一个元素，

实际上整个数组一样是有地址的，用一个&就可以把整个数组代表的地址给取出来，指向数组的指针数组中的元素就是整个数组的地址，比如&a(但是a和&a的数值上是一样的，但在**步长**上就不一样，*如果是整个数组的地址，那么他在运算符中的地址的步长就是加上它整个数组单位的*。如果是二维数组那肯定要&a。)，所以这时候就要先要访问大数组的元素，被称为“行”，再访问小数组中的元素，被称为“列”，（行优先）这就是高级语言意义上的二维数组，与双重循环非常的相像

具体实例：
```c
double aa [2]

```

这其实也算是一种指向指针的指针，所以被称为是二级指针
形式
**p

数组同样可以应用到`typedef`给“重命名”看做一个类型，具体怎么做等我看完函数的`typedef`再说吧

### 指向函数的指针数组
函数有地址，把函数的地址给存放到指针数组，但是具体还得再看看


#### 二维数组
每一个元素是类型相同，长度相等的一维数组

定义方式和初始化方式
```c
int a[3][4]={1,2,3,4,5,6,7,8}
//因为C系语言都是行有限，所以列一定不能少写，他是划分二维分组的重要的依据
//比如这个代码里的分组就是以四个为一组，行倒是可以省
int b[][4]={1,2,3,4,5,6,7,8} //这样倒是可以嗷
//另外如果想更标准更直观区分出行列也可以这样写
int c[][3]={{1,2},{3,4,5}}　//被包的每一个大括号都是一行数据
```
**以指针方式访问二维数组**
**二维数组名是逻辑意义上的二级指针**，但是他不能直接赋给二级指针值

二维数组的数组名：行地址

第i行第j列的地址：
a[i]+j
    *(a+i)+j
        &a[i][j]

#### 数组作函数参数
- 数组元素作参数没区别
- 数组名作参数传递地址
- 数组元素和数组名都可以引用参数



指针的大小无论是什么类型的都是4个字节
数组在作为函数的形参的时候后都被函数退化认为是简单的指针。

#### 数组的排序
**选择排序法**
按降序排序
若一组整数放在数组a中
第一趟找出最大值，放在a0
以此类推


下标：index

2021年5月12日15:08:25
---
数组的排序方法
选择排序：选个最大的再交换排序
冒泡排序：发现顺序不对就交换排序

### 数组的查找：
#### 二分查找法
假设整形数组a包含10个元素**且已有序升序排列**
设置三个变量 low high mid
[low，high]表示查找的下标区间，初值设置low=0

high=n-1, mid表式这个区间的中值
通过比价待查数x，与a[mid]，若相等则查找成功
若小于，则high为mid-1，若大于则置low+1，**继续在这两个变量区间查找，当出现low>high,查找就失败了

数组的插入和删除
很困难

#### 2021年5月19日14:32:40

---
**数据结构**
数据结构中的逻辑结构：
集合：只有除了“同属一个集合” 的相互关系外，别无其他关系
线性结构：一对一
树形结构：一对多
图形结构：多对多
实际上在C上的数据结构中指针的泛用性还行

指针：
内存：
**无符号**十六进制的地址：每个**计算机位**的内存地址，实际上每个字节永远是八位，内存地址不过就是门牌号，32位就是32位的门牌号上限，64位就是64位门牌号的上限，所以说32位有内存上限而64位几乎无限了


实际上这些地址还是八位字节
当你用`int`初始化的时候，实际上还是调用了四个**线性相邻**的内存块，但是地所谓的地址还是**首字节的内存地址**（这也是为什么指针也需要定义数据类型的原因）

与C的规定有关，定义了指针的变量只能存地址，定义了内容的就不能放地址

间接寻址：存放变量地址的变量以达到访问地址的
这 就 是 指 针

其实指针还是很强大，因为他能无限制操控他所指向的地址的内存区块，如果指向关键代码区，则会很危险

指针步长
指针的步长和所指空间类型有关
p++=

指针作函数的返回值————指针函数
指向函数的指针————函数指针

### 字符指针
**一些预览**












