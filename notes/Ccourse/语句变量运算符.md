### 变量和常量

由小学方程式引出：

**观察与分析为重**：一样不变为constant；会随需求而变的为variable

**数据类型**：*一种变量的*`单位`

**为什么`data type`会放在data前面？**：

先定义空间，再放数据 *（一种“预约”的解释）*。预约→`声明`。“预约”要在填入数据之前，要不然没法分配大小。

### 语句
#### 分号
C语言中为了区分每一条命令，而整的一种区分符，`python就是直接省略了,一行一条指令`
#### 赋值与声明
把`data`放进‘预定’好的房子，而预定号房子这个过程，就叫做`声明`。而用新的`data` **完全替代** 原来的数据，这个行为就叫做`赋值`

![alt text](image.png) 声明
![alt text](image-1.png) 赋值
- **初始化** ：`声明`和`赋值`同时进行时的名字，如：
```c
int x = 2;
```
- **const**
~~~c
const int a = 6;
~~~
**WHY?const放在int前面**？: 
类似形容词的顺序，名词前最近的形容词，越能代表该名词的 **第一特征**，所以对于这块`内存空间`中 int 特征最明显，const次之。包括`long`与`short`，实际上也是一样的。

~~(实际大部分编译器根本不管你这个错误)~~

`long`：字节 × 2
- `long long`就是 × 4
  
`short`字节 / 2
- 但是并没有`short short`
  
`unsigned`：负数的字节扩容到正数

   **声明规则**：总之变量名不能让数字在最前面，但能允许下划线，
  
#### 字节长度
 `int`变量有4个字节，每个字节占8位（8bit，8个二进制码）————→ 数据量 = 2^n×8^

> 课程引入：使*在不扩增字节数的情况下*：扩增数据的表达量,所以有了更高的进制（？really？）

#### 符号位
符合人的习惯，将判断符号的第一位放在“最左侧”，但是使得本身数据类型能表达正负，但是符号位占了一个位，所以使得表达的正数含量要减去一个指数，不过总个数量是不变的；可以通 过`unsigned`adj来使符号位失效，**用于储存更多的正数**（实际也就多一个次方多*2，总数依然是不变的）

**强制检测八进制赋值问题（解释格式说明符）**：

```c
printf("%d %o %x");
````
键入的时候，可以靠%o与%x这种格式说明符强行把字符串转化成对应的进制（八进制，十六进制）

平时可以在 **数字最前面** ，通过特定的前缀来标识：
- **八进制（Octal）**：以`0`开头表示八进制数。
- **十六进制（Hexadecimal）**：以` 0x `或 `0X`开头表示十六进制数。
- **二进制（bit）**：以`0b`或`0B`开头表示二进制数。（**C99后才有**）

#### 浮点数
##### 浮点数在`cell`集合里的储存方式


一些浮点数的printf输出格式：

- 好像没有具体像讲int一样讲float的范围？可以问一下（计算机原理，但是这个也不会是黄老师教了）
~~~c
#include<stdio.h>

int main(){
    float a = 3.1415926;
//这里面的小数点就是实际值的小数点位置
    printf("%.3f\n",a); //小数点后面数值表示保留的小数位数（**自动四舍五入**），如果该值过大，则会补“空格”或0（GCC是补0吧）。
    printf("%10.3f\n",a); //小数点前面的数值表示该浮点数所占的字节数
// （**但是如果本身超过了规定的值(比如本身就是3个字节，你给它限定2字节，它要怎么限定嘛！)，会被无视掉**）
    printf("%-10.3f\n",a); //减号代表左对齐，使补齐的空格往右边补
    printf("%+10.3f\n",a); //这个加号不是正常的加，也不是右对齐，而是强制显示符号
    printf("%09f",a);   //前面加个0，表示补0而不是补空格（补到9位数为止）

    return 0;
}
~~~

~~~c
输出：
3.142
     3.142
3.142
    +3.142
03.141593
请按任意键继续. . .
~~~

一些细则：

1. 如果数字位数超过指定宽度，会完整显示，不会截断：
~~~c
printf("%02d\n",123);   //输出：123(不会截断)
~~~
2. 负数也能正确处理，宽度包括负号：
~~~c
printf("%05d\n", -42);    // 输出：-0042
~~~
3. 对于浮点数，宽度包含小数点和小数部分：
~~~c
printf("%010.3f\n", 123.456);    // 输出：0000123.456
~~~

#### 字符串

按照黄老师的理解，`char`就是`const short short int`。它只占用了**一**个字节，**然后通过权威机构把各字符对应起来（C语言ASCII码）。** ~~~JAVA用的是unicode~~~

> 一个人穿上**大白褂**就会变成医生。
> 但是他本身却是一个学生。
> **大白褂**使得他的身份转化

而字符串中的 **大白褂** 则是反斜杠`\`，名字为 ***转义字符*** 如`\n`即为换行符，通过该例子可以明白，转义字符将一些字符量，变成代表另一个 **char** 值的 **便捷方法**。

> \n 例子可知，将 n（ASCII码 ；110）给直接成 ‘换行’（ASCII码：10）

- 再记一个：`\t`水平制表符（就是Tab键啦），ASCII码 = 9。

##### 字符串与`char`数组的区别
- 黄箐说过，char 就是int，所以很好理解，char数组也可以按照其他类型数组一样可以正常for打印，初始化，等等一模一样的操作，只不过char能接受单引号字符能强制转化一下罢了
- `字符串`可以省去你不断打单引号的劳役之苦，不过作为代价，他会在你所有字符"垒在一起"的最后面，添加了一个空字符 **（ASCII = 0）** ,这个其实非常好，不用再事先打出数组的长度，而是在各种场景下，**把空字符当成一个标识符**，能便利我们解决很多很多问题
  
    - 不过C也挺聪明的，这东西早就封装好了用，`printf("%s",s);`既可以直接打印，这里的s其实是一个指针，为什么要传入指针， **是因为C中其实没有字符 串 的数据类型**
    - 这也解释了为什么，好像“唯独”字符串，在`scanf`函数中，**不需要加上取地址符`&`**

#### 顺便再讲一下`scanf`吧
- 最简单的理解方式，就是你要键盘给你输入东西，那你总要一个地址吧，要不然，我草，我哪知道我给你输入那些值放哪去哦。**所以scanf逗号后面的东西无一例外全都是地址**
- 

### 算术
#### 基本运算符highlight
`%`运算符是对整数进行位操作优化的，其本质上依赖于二进制整除操作。所以某一元为浮点数报错很正常的 **因为浮点数都不是基于二进制十进制转换来储存的**。

不管浮点数也不是完全用不了mod，还有`fmod`函数，不过他返回值也是一个`double`浮点数罢了。

#### “x++（后置递增）与++x（前置递增）”
辨析

~~~c
#include<stdio.h>

int main(){
    int x = 1;
    printf("%d\n",++x);
    printf("%d\n",x);

    return 0;
    //output : 1，2
}
~~~
`前置递增`为，**先使用后增加**，**先**返回当前值，再进行递增
~~~c
#include<stdio.h>

int main(){
    int x = 1;
    printf("%d\n",x++);
    printf("%d\n",x);

    return 0;
    //output: 2，2
}

~~~
`后置递增`为，**先增加，后使用**，**先**递增，再返回值。

~~实际上我从来都是把x++当成单独的语句来整的，也是第一次知道这个知识点，我还以为只是个人习惯不同~~

这个知识点对`for`的`()`影响微乎其微

不过`++x`确实也有性能上微弱的提升（不需要建立临时副本），但其实现在编译器也没什么必要。



### 运算符
> 黄老师解释`printf("%d",10.0/3);` : 10.0的官职比较大（它掌握了整数和小数部分），小的要像大官“靠拢”，所以“弱”一点数据类型转化成强一点的数据类型。

所以当 **数据类型不一样的变量** 进行运算时，要把“弱”转换成“强”，这幢转换就叫做：
#### **隐式类型转换**
规则：主要是为了信息的完整性（若小变大则会导致数据的`截断`，比如数据的溢出`long 转 short`和精度的丢失`float 转 int`）和 **算术一致性**。
还是码一下隐式转化的官方定义吧：
> 在C语言中，隐式类型转换**（也叫自动类型转换）**的标准规则比较复杂，让我用中文详细解释：
> ### 1. 整数提升（Integer Promotion）
> 小于int的整型（如char、short）在运算时会自动提升为int：
> `````c
> char a = 'a';
> char b = 'b';
> // a + b 的运算会先将两个char提升为int，然后再进行加法
> `````
>
> ### 2. 算术转换（Arithmetic Conversion）
> 当运算符的操作数类型不同时，会按照以下"等级"转换为较高等级的类型：
>
> ````c
> long double > double > float > 
> unsigned long long > long long > 
> unsigned long > long > 
> unsigned int > int
> ````
>
> 例如：
> `````c
> int i = 10;
> float f = 3.14;
> // i + f 的结果会是float类型，因为float的等级高于int
> `````
>
> ### 3. 赋值转换（Assignment Conversion）
> 右侧表达式的值会转换为左侧变量的类型：
> `````c
> int i;
> double d = 3.14;
> i = d;  // d会被截断为整数后赋值给i
> `````
>
> ### 4. 函数调用转换（Function Call Conversion）
> 实参会转换为形参声明的类型：
> `````c
> void func(int x) { }
> char c = 'a';
> func(c);  // c会被提升为int
> `````
>
> ### 5. 数组到指针的转换（Array to Pointer Decay）
> 除了少数情况外，数组名会自动转换为指向其第一个元素的指针：
> `````c
> int arr[5];
> int *p = arr;  // arr自动转换为&arr[0]
> `````
>
> ### 6. 函数到指针的转换（Function to Pointer Conversion）
> 如我们刚才讨论的，函数名会自动转换为函数指针：
> `````c
> void func() { }
> void (*fp)() = func;  // func自动转换为指针
> `````
>
> ### 注意事项：
>
> 1. **可能的数据丢失**：
> `````c
> int i = 1000;
> char c = i;  // 高位数据会丢失
> `````
>
> 2. **精度损失**：
> `````c
> double d = 3.14159;
> float f = d;  // 可能损失精度
> `````
>
> 3. **符号转换**：
> `````c
> int i = -1;
> unsigned int u = i;  // i会被解释为一个很大的正数
> `````
>
> 4. **不同长度的整型转换**：
> `````c
> long long ll = 123456789012345;
> int i = ll;  // 高位数据会丢失
> `````
>
> 这些规则是C语言标准（如C89、C99、C11等）定义的，编译器必须遵循这些规则。理解这些规则对于写出正确的代码和避免潜在的bug非常重要。

> - **有符号类型（signed）**：如果较小的有符号类型被转换为较大的有符号类型，**符号位扩展**会发生。例如，一个 `char`（1 字节）转换为 `int`（4 字节）时，会将最高位（符号位）扩展到新的高位字节中，以保持正负号的一致性。这叫做**符号扩展**。
>   举例说明：
> ```c
> char a = -5;  // char 类型是 1 个字节
> int b = a;    // int 类型是 4 个字节，符号扩展
> // 在内存中，-5 可能表示为 11111011（二进制），转换后 b 为 11111111 > 11111111 11111111 11111011
>   ```
  

> - **无符号类型（unsigned）**：如果较小的无符号类型被提升为较大的无符号类型，**零扩展**会发生。即高位的额外字节都填充为 0。
>  举例说明：
>  ```c
>  unsigned char a = 200; // 200 的二进制为 11001000
>  unsigned int b = a;    // 转换后，b 为 00000000 00000000 00000000 11001000
>  ```

其实还有一种
#### 强制转换
也比较通俗易懂
~~~c
int c = 98;
printf("%d",c);
char c = (char)x;
~~~
就两种途径（目前可以用到的），可提供更高的用户自由度，但是一般来时很难用到。

#### 比较运算符
`>` `<` `==` `!=`成立就返回 1 。不成立就返回 0.
#### 逻辑运算符

**只有** 与`&&`， 或`||`， 非`!`。这个是条件判断，所以 **没有异或**。异或要在位运算里才能见得到

**短路现象**：如果结果已经可以确定，**后续的表达式将不会被计算**。这种机制可以提高程序效率，同时避免不必要的计算

**优先级**：
直接CV了，查个表的事：

在 C 语言中，运算符的优先级决定了表达式中各个运算符的计算顺序。优先级越高的运算符会先被计算，如果优先级相同，则根据运算符的结合性（左结合或右结合）来决定运算顺序。

以下是 C 语言中常见运算符的优先级表，从高到低列出，同时标明结合性：

| 优先级 | 运算符                            | 描述                                      | 结合性       |
| ------ | -------------------------------- | ----------------------------------------- | ------------ |
| 1      | `()` `[]` `->` `.`                | 圆括号、数组下标、结构体成员、指针访问     | 左结合       |
|        | `++` `--`                        | 后置递增和后置递减                        | 左结合       |
| 2      | `++` `--` `+` `-` `!` `~`         | 前置递增、前置递减、正负号、逻辑非、按位取反 | 右结合       |
|        | `*` `&`                          | 指针解引用、取地址                         | 右结合       |
|        | `sizeof`                         | 计算数据类型的大小                        | 右结合       |
| 3      | `*` `/` `%`                      | 乘、除、取模                              | 左结合       |
| 4      | `+` `-`                          | 加、减                                    | 左结合       |
| 5      | `<<` `>>`                        | 左移、右移                                | 左结合       |
| 6      | `<` `<=` `>` `>=`                 | 小于、小于等于、大于、大于等于            | 左结合       |
| 7      | `==` `!=`                        | 等于、不等于                              | 左结合       |
| 8      | `&`                              | 按位与                                   | 左结合       |
| 9      | `^`                              | 按位异或                                 | 左结合       |
| 10     | `丨`                              | 按位或                                   | 左结合       |
| 11     | `&&`                             | 逻辑与                                   | 左结合       |
| 12     | `丨丨`                             | 逻辑或                                   | 左结合       |
| 13     | `?:`                             | 条件运算符（三元运算符）                  | 右结合       |
| 14     | `=` `+=` `-=` `*=` `/=` `%=`     | 赋值及复合赋值                           | 右结合       |
|        | `<<=` `>>=` `&=` `^=` `|=`       | 移位及按位运算的赋值                      | 右结合       |
| 15     | `,`                              | 逗号运算符                               | 左结合       |

##### 说明：

- **结合性**：
  - **左结合**：从左到右计算。例如，`a - b - c` 会先计算 `a - b`，再计算结果减去 `c`。
  - **右结合**：从右到左计算。例如，赋值运算符 `a = b = c` 会先计算 `b = c`，然后将结果赋给 `a`。

- **优先级的影响**：
  - 具有更高优先级的运算符会先进行计算。例如，在 `3 + 4 * 5` 中，`*` 的优先级高于 `+`，所以先计算 `4 * 5`，然后再加上 `3`。

- **圆括号 `()`**：
  - 圆括号具有最高优先级，可以强制改变表达式的运算顺序。例如，`(3 + 4) * 5` 中，`()` 会使得先计算 `3 + 4`，然后再乘以 `5`。


#### 位运算符
>通俗来讲，*位运算符就是二进制的算术运算符*，所谓**按位运算**就是指先将数字转化成二进制数字，然后按照二进制的规则进行相关的运算。
##### 位运算符详细解释

`&`（按位与 *AND*）: 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0
例如:   
~~~C
        0 0 1 1 1 0 1 1
        1 0 1 1 0 1 0 1
     --------------------
        0 0 1 1 0 0 0 1
~~~

`|` （按位或 OR）: 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。
例如:  
~~~C
        0 1 0 1 0 0 1 1
        1 0 0 1 1 0 0 1
      -------------------
        1 1 0 1 1 0 1 1
~~~
`~`（按位非）: 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1
例如:  
~~~C
        1 1 0 0 1 0 1 0
      ------------------
        0 0 1 1 0 1 0 1
~~~
`^`（按位异或）: 按位异或运算符：当两对应的二进位相异时，结果为1
例如: 
~~~ C
        0 0 1 1 0 1 0 1
        0 1 0 1 0 1 0 0
      ------------------
        0 1 1 0 0 0 0 1
~~~
`<< `(有符号左移位) : 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。
例如:  
~~~C
<< 1    print(6 << 1) # 6 * 2**1
        0 0 1 0 1 0 1 1 
      ------------------
        0 1 0 1 0 1 1 0
~~~
`>>`（有符号右移位）: 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数，低位丢弃，高位补0
例如:
~~~C
  >> 1  print(6 >> 1) # 6 // 2**1
        0 1 0 1 0 1 0 1
      ------------------
        0 0 1 0 1 0 1 0
~~~

##### 位运算符的特点
1. 效率高，内存消耗少 *在老旧的电脑上位运算符效率会大大地大于加减法，但是经过intel的~~挤牙膏~~改进，现在已然和正常整形数据的加减法差别不大了，但还是要大幅度快于乘法除法*
<br>
2. 在某些情况中，位操作可以避免或者减少在一个数据结构上需要进行循环的次数，并且可以成倍的效率提升，
因为位操作是并行处理的。但是位操作的代码比较难以编写和维护。
<br>
3. 唯一的二进制运算符




