## 数制
#### 预备概念
- **基：** 二进制的基为二，八进制的基为八，十进制的基为十，十六进制的基为十六，以此类推。
<br>
- **位权：** <font color=red>从小数点开始</font>，依次向左右两边**用基的指数**编号，向左为0, 1, 2，…,向右为-1，-2，-3，…。
以二进制为例
从小数点开始，向左位权依次为：
2^0^，2^1^，2^2^
向右位权依次为：
2^-1^，2^-2^
其他进制以此类推
<br>
- **数码：** 各数制中每一个单独的数字就是它的一个数码
---
### 常用数制的简单简单描述：
- **十进制（DEC）——** 逢十进一，人类之中拥有绝对统治力的进制*，无论是现代还是古典的数学上的默认进制
- **二进制（BIN）——** 逢二进一，只有01，数字电路内核中最常用的进制，用0和1代表各种元件中两种截然不同的稳定状态（比如开关或者动停）提高可靠性和抗干扰能力，加上0和1刚好对应逻辑学中的false与true，这些都是选用二进制最根本的原因
- **八进制（OCT）——** 逢8进一，在计算机的早期时代，为了更简洁地表达出二进制而产生的特殊数制，一位八进制数可以映射为三位二进制
历史上八进制的广泛应用主要是在12-bit、24-bit和36位的机器上。在如今32-bit，64-bit盛行的时代，肯定不如十六进制。
现在八进制的主要应用应该是在处理UTF-8编码和Linux 文件权限或者某些文件结构中的数据存储方式上
- **十六进制（HEX）——** 逢16进一，大于9的基数则使用英文大写字母A~F来代替，用法以及来源跟二进制相同，是目前计算机操作系统中最广泛使用的精简二进制串的数制


>*：十进制为什么在全世界的数学领域都具有绝对的统治力是因为阿拉伯数字的全球流行（为什么全球流行是因为各个地区古代的主流文化包括华夏欧洲伊斯兰都不约而同的使用了十进制作为最基础的数制，大概因为是人有十根手指的原因），不代表其在**任何环境**都具有优势，比如计算机中的数制就是以2的次方为基础的数制进行表达

**不同进制数的对照表：**
![](https://img-blog.csdnimg.cn/20200629190325638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM3ODgzNQ==,size_16,color_FFFFFF,t_70)

---
### 数制的转换
#### 2^n^进制和二进制的互换

>八进制和十六进制的广泛使用就是为了更方便的在计算机系统内表达大量的二进制串，这三个之间的互转就是现在常用数值里最简单的，这是因为无论八进制还是十六进制，他们的**基**都是二的整数次方，所以说，就算有更高（32进制）或者更低的（4进制），他们都遵守着同样的规律：

**二进制转2^n^进制**
1. 将二进制**从右向左，每n位*一组（不足n位左补0）**，分完组后**正序输出**
2. 再将**每个n位数码组**根据对照表转化成**单个的**2^n^进制数码
3. 再将每个2^n^进制数码**正序输出**

**2^n^进制转二进制**
1. 将每个2^n^进制数码都转化成对应的**n个二进制数码**
2. 去掉首部多余的0，然后**正序输出**

`example：`
```
将二进制（1101011111011）转换为八进制
解：
1.（001，101，011，111，011）   //分三位一组
2. （1，5, 3，7,3） //将每个分组转换成单位的八进制数码
3. 得出结果：（15373）  //将每个八进制数码正序输出  

将十六进制（d7de3）转换位二进制
1. （1101,0111,1101，1110，0011）   //将每个十六进制数码都转化成对应的4个二进制数码
2. 得出结果（11010111110111100011） //去掉首部多余的0，然后正序输出
```
#### 十进制和各种进制的互换
**非十进制转十进制**
- 方法：按权展开相加

如将 (11010.101)2写成权展开式为：
![](https://img-blog.csdnimg.cn/20200629190749553.png)
~~虽然很想用精确的语言来解释，但想了想还挺费脑子的，反正这个笔记也就曾嘉轩看，不如举例子他自己融会贯通就完事了~~

**十进制转非十进制**
- 整数部分
    - 不断整除基数取余，然后倒序输出
```c
//尝试着用codes解释
#include<iostream>
using namespace std;
int main()
{
	int ji, item, k, c, i=0;
	int a[1000];
	cout << "please enter the decimal number:" << endl;
		cin >> item;
	cout << "please enter the cardinal you want to convert:" << endl;
		cin >> ji;
	while (item >= ji)
	{
		k = item % ji;
		item /= ji;
		a[i]=k;
		i++;

	} 	
	a[i] = item;
	cout << "the result is:";
	for (int j = i; j >= 0; j--)

	{

		c = a[j];
		cout <<c;

	}
	return 0;
}
//庆祝一下自己第一个包含实例的程序
```
- 小数部分
    - 只把小数部分提出来，不断递归乘基数直到不在存在小数部分（小数点右边不含值）

```c
//完整code演示
#include<iostream>
using namespace std;
int main()
{
	int ji, item, k, c, d, i = 0, z = 0;	double temp, xiaoshu;
	int a[1000], b[1000];
	cout << "please enter the decimal number:(float is OK)" << endl;
	cin >> temp;
	cout << "please enter the cardinal you want to convert:" << endl;
	cin >> ji;
	xiaoshu = temp - int(temp);
	item = int(temp);
	
	while (item >= ji)	//整数部分的输出
	{
		k = item % ji;
		item /= ji;
		a[i] = k;
		i++;

	}
	a[i] = item;
	cout << "the result is:";
	for (int j = i; j >= 0; j--)

	{

		c = a[j];
		cout << c;

	}
	cout << ".";
	double dji = ji;
	while (xiaoshu-int(xiaoshu)!=0)	//小数部分的逻辑
	{
		k = int(xiaoshu*ji);
		xiaoshu *= dji;
		xiaoshu = xiaoshu-int(xiaoshu);
		b[z] = k;
		z++;
		if (z >= 10)	//保留小数的地方
			break;
	}
	for(int m = 0; m!= z ;m++)
	{
		d = b[m];
		cout << d;

	}
	return 0;
}
```
- 注意：此程序只能处理10以下的进制的转换，十以上的得对特定数码进行宏定义
---
###　二进制的算术运算
当两个二进制数码表示两个数量的大小，并且这两个数进行数值运算，这种 运算称为算术运算。算术运算包括“加减乘除”，**但在二进制中，减、乘、除最终都可以化为带符号的*加法运算*。**
#### 算术运算

- 和十进制算数运算的规则相同
- 逢二进一、借一当二
- 特点：加、减、乘、除 全部可以用移位和相加这两种操作实现。简化了电路结构

所以数字电路中（也就是计算机中）普遍采用二进制算数运算

**二进制中的加法规则**
![](https://img-blog.csdnimg.cn/20200629211852333.png)
**二进制中的减法规则**
![](https://img-blog.csdnimg.cn/20200629211940667.png)

实际上如果真要0-1的话还是会等于-1的，但关于为什么这张图里面的是0-1=1
>0-1=1是指本位，不考虑借位的情况。
例如1位十进制数，其范围是0~9，我们从9开始，不断减1，就会得到8、7、6......，但减到0的时候，再继续减1会怎样呢？若不考虑向高位的借位情况，只看本位：0-1=9。
这与二进制数运算中0-1=1是类似的。

**二进制乘法规则**
![](https://img-blog.csdnimg.cn/20200629211949999.png)
手算：换成十进制再乘
计算机算：用补码运行（具体后面再讲）
**二进制的除法规则**
![](https://img-blog.csdnimg.cn/20200629212015310.png)
>有一说一不管什么进制都是逢x进1那一套，都可以用十进制教的乘法除法无限套,只要注意别把逢十进一氪金DNA里就行

### 原码-反码-补码
#### 前置知识
- **机器数**————**一个数在计算机中的二进制表示形式**, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的**最高位**存放符号, 正数为0, 负数为1.
	- 比如，十进制中的数 +3 ，**计算机字长为8位**，转换成二进制就是00000011。如果是 -3 ，就是 10000011
	此例子中的00000011和10000011就是机器数
- 因为计算机并不像人脑一样非常方便地判断值的正负，所以使用符合位对于计算机电路设计是一个必要之举
- **真值**————为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值
---
#### 原码
原码的表示方式为：

- 原码就是符号位加上真值的绝对值,
-  即用第一位表示符号, 其余位表示值。数值上和机器数相等，~~不过它们两个倒是不同领域的概念就是了~~
- 所谓原码就是机器数
#### 反码
反码的表示方法是:

- 正数的反码是其本身

- 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。

>[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反


- 所以负数的反码属实不好判断数值
#### 补码
补码的表示方法是:

- 正数的补码就是其本身

- 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)(正所谓**补**)
>[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补


---
### 三码的作用
>建议：**首先先把概念给“死记硬背下来”，再来分析**
- 问：整这三个码有什么鸡掰用，直接让计算机像我们人脑这样算不就行了

	1. 所有储存在计算机中的值，都是以原码的形式，而不是真值，所以必须得带符号位进行计算
	2. 让计算机辨认符号位会使电路复杂化，同样的，多加一个减法器也会让电路复杂化，所以计算机中只有加法，但如果包括符号位计算，那只是原码的计算会让负数的加减法产生很多的错误，比如我们希望 （+1）和（-1）相加是0，但计算机只能算出
	```
	0001+1001=1010 (-2)
	```
	这并不是数学期望的结果

#### 反码的诞生
为什么会出现负数加法失真的情况呢？

因为在有符号位的二进制表里，正数每增加一个二进制单位对应的真值数学意义上的**递增**，而负数中，每一个二进制单位的增加反而是**递减**，

如果需要使负数加法成立，就必须让负数与他对应的二进制码是同步递增或者同步递减。

于是聪明的人类就采用了将负数二进制除符号位取反的方式，创造了下表
![](https://img-blog.csdn.net/20180403095015188)
这样下来，负数的加法就能正常运行了

#### 补码的诞生
从反码表来看，所有的正负数在不跨越0的情况已经能正常运算了

但问题就出在0身上，[1111_1111]和[0000_0000]都表示0，这导致在实际计算中每当跨过0一次，就有一个单位的误差。


而要解决这个问题只需要非常简单地再加个1行了，这样真值0也就都变成了0000_0000。
表也变成了这样：

![](https://img-blog.csdn.net/20180403101055691)

这就是补码的诞生，从上面的图中发现还有一个[1000_0000]的二进制没有对应任何真数，于是就规定了这个数的真数是-128

---

#### 计算机中
如果看表就可以发现这些二进制都是八位，实际上就是一个字节的长度
事实上在现在的几乎所有操作系统中都是这样，每个字节的十进制的区间都是[-128，+128]，在跨越这个区间的运算时，在实际二进制的运算中超过范围其实就是对256的取余预算（x+128）mod 256 - 128。

**注意：实际上，三码解释的笔记很多证明推导过程并不严谨，只是为了此时的曾嘉轩能更好理解三码的作用**

---
### 可能严谨但也可能不严谨的讨论
首先上面的推导证明似乎是想要把补码的作用往“服务于”计算机操作这一方向去靠。但实际上补码的诞生真的要比计算机诞生早的多。所以与其说补码是为了服务于计算机的，不如说补码的诞生只是为了让**加法完全代替减法**

虽然说在数学的学习上，加一个负数就等同于减法，但这样的“原码”计算并不是让加法完全替代减法，只不过是换了一种说法而已，实际上在处理这一类计算的时候，只要出现了-号，那么必然会出现比对双方的绝对值然后大的减小的最后看绝对值大的哪一个数据确认符号，**本质上依然是减法**

但是补码是一种全新的定义方式

如上图所见，它让数码单位的递增和递减于真值的递增和递减完全相同，数码单位的减少就是对应数据的减少，增加就是对应增加，和正数的法则完全一致。

和现在数学常用的负数表达法不同，负号更像是一个方向相反的表示符号，后面的值依然是绝对值，而绝对值本质上就是正数，因为距离不可能存在着负数。也就是说数学上不存在绝对的负数。只不过受制于二维坐标系的“方向”，而生造的负数，

实际上正数和负数并不是完全相对的，而补码正是让负数和正数完全相对，就算是最基本的运算法则，也能相互互通，让加法完全代替减法。






























