链表结点有的数据：
1.  **信息域**里，可以包含多个数据项，你可以结构体再套一个结构体，（比如学生学号性别之类的信息）
2. 
 ```c
 typedefint datatype;
 typedef struct link_node{
    datatype info;
    struct link node *next;}node;
    typedef node* linklist; //说实话，有点脱裤子放屁的感觉……还不如就node*（指向结点的指针）来得直观
```

3. 建立一个空的单链表，用函数去建立，为什么用函数（因为他这算是一种线性表ADT基本操作的实现方式）

指针化的形参操作
```c
void init(linklist *p){     /*initial，而且就是node*（节点的指针时链表节点的指针时链表）
啊啊啊我好讨厌这个命名方式*/
    *p = NULL;
}
```
开辟新指针空间的操作
```c
node* init(){
    return NULL
}
```
**头指针**
一个单链表可以没有 **头结点** ，但是一定不能没有 **头指针**（数据类型【node*】，或者说是linklist（指向结点的指针）），**头指针**只声明没有分配任何存储空间，永远指向指针实际有分配的第一个节点位置，首元结点||头结点，如果你增删改查改变了这两项，那么你头指针的指向也一定需要更新。

**堆栈方式{建立}单链表**
（头插法）
1. 初始化head指向空
2. 声明一个node* 空间 s
3. 把数据域填上，把指针域指向head（在最开始，指向的就是NULL，第二次，则是指向了上一次s的地址）
4. 把头指针指向s
5. 然后s再新开辟一个结点空间，重复以上步骤。
**所以可以看出来**
- 符合栈的FILO原则，因为第一个生成的节点再逻辑上对末尾，最后一个生成的节点在逻辑上的开头
- 如果head未初始化的话，那么会导致末尾节点的指针域没有指向NULL，造成之这边非法访问→使得main函数不能最终返回0，被操作系统“强制宕机”

**队列方式建立单链表**
（尾插法）
1. 多初始化一个rear的指针，定义为他 **永远指向逻辑末尾的节点**
2. 声明一个node* 空间 s
3. 如果原链表还是空（head没指东西），先让head指向s，r先按兵不动（还是指向空），等这个操作做完后，使得r指向同一个节点
4. 接着，重复上面的操作使s开辟新的节点，每次都使s的next指向为空，然后把r此时指向的next指向s，再把r指给新s

**删除node**（无头结点）
单链表的话，如果你不多额外再申请一个变量尾随s，**你是无法走回头路的**，所以你还得新声明一个pre指针，能使得能随时追踪前驱元素，然后通过pre把前驱元素的next指向s的next，就能够随时去看了
具体操作位：
首先定义：
1. s一开始等于head，然后pre最开始等于null
2. 往后移动前，记得先想想
3. 接着开始往后移动，经典的我先等于你然后我再等于我的next




链表就是珍珠串链，懂得它的ADT用基本方法就能实现所有的

**3.23循环链表 双链表**：
